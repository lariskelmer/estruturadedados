# Guided Project - Performance and Complexity Analysis

This guided project was developed based on the "Introduction to Algorithms" course on the dataquest.io platform. It focuses on analyzing the performance and complexity of algorithms, as well as comparing different implementation approaches. The main objectives of this project include:

- Understanding how to analyze the time and space complexity of an algorithm.
- Learning how data pre-processing can significantly speed up an algorithm.
- Exploring data classification techniques and efficient search on classified data.
- Implement efficient algorithms for specific tasks, such as finding pairs of equal values in a list and locating two values whose sum is equal to a given value.

## Data Set

The dataset used in this project comes from a laptop store and includes information such as ID, Brand, Product, Type, Size (in inches), Screen Resolution, CPU and RAM. This data is used to illustrate and analyze the performance of the implemented algorithms.

## Inventory class

To facilitate data processing, a class called `Inventory` was created. This class allows laptops to be instantiated and their characteristics to be manipulated. It has several methods, each with two versions: an initial version and an optimized version. The optimized versions aim to improve the performance of operations.

The following describes the time complexity of the main functions implemented:

### `get_laptop_from_id`
- **Big O (O)**: O(n), onde n é o número de laptops anexados. A função percorre a lista de laptops para encontrar o laptop com o ID correspondente. No pior caso, ela pode ter que percorrer toda a lista.
- **Big Theta (Θ)**: Θ(n), pois a função sempre precisa percorrer todas as linhas para encontrar o laptop ou determinar que ele não está presente.
- **Big Omega (Ω)**: Ω(1), no melhor caso, quando o laptop desejado está na primeira posição da lista.

### `get_laptop_id_fast`
- **Big O (O)**: O(1). Essa função usa um dicionário `self.id_to_row` para verificar a existência de um laptop com o ID fornecido. A operação de busca em um dicionário tem complexidade média O(1).
- **Big Theta (Θ)**: Θ(1), pois a função sempre executa uma única verificação de presença no dicionário, independentemente do tamanho do dicionário.
- **Big Omega (Ω)**: Ω(1), no pior caso, a função precisa de apenas uma verificação no dicionário.

### `check_promotion_dollars`
- **Big O (O)**: A função realiza duas iterações aninhadas sobre a lista de laptops, onde a primeira iteração tem uma complexidade de O(k), e a segunda iteração também tem uma complexidade de O(k).
Portanto, a complexidade de tempo total é O(k^2), onde k é o número de laptops.
- **Big Theta (Θ)**: A complexidade de tempo Θ(k^2) é uma descrição precisa da complexidade, pois a função sempre precisa verificar todas as combinações possíveis de preços.
- **Big Omega (Ω)**: A função sempre precisa verificar todas as combinações possíveis de preços, o que implica que a complexidade de tempo Ω(k^2) é uma cota inferior precisa para a função.

### `check_promotion_dollars_fast`
- **Big O (O)**: A função realiza uma iteração sobre o conjunto self.prices (O(k)) e, para cada preço, realiza uma verificação se dollars - price está presente no conjunto (O(1) em média). Portanto, a complexidade de tempo total é O(k), onde k é o número de preços únicos.
- **Big Theta (Θ)**: A complexidade de tempo Θ(k) é uma descrição precisa da complexidade, pois a função percorre todos os preços únicos uma vez.
- **Big Omega (Ω)**: A complexidade de tempo Ω(k) é uma cota inferior precisa para a função, pois a função sempre precisa percorrer todos os preços únicos.

### `find_laptop_with_price`
- **Big O (O)**: A função realiza uma iteração sobre o conjunto self.prices (O(k)) e, para cada preço, realiza uma verificação se dollars - price está presente no conjunto (O(1) em média). Portanto, a complexidade de tempo total é O(k), onde k é o número de preços únicos.
- **Big Theta (Θ)**: A complexidade de tempo Θ(k) é uma descrição precisa da complexidade, pois a função percorre todos os preços únicos uma vez.
- **Big Omega (Ω)**: A complexidade de tempo Ω(k) é uma cota inferior precisa para a função, pois a função sempre precisa percorrer todos os preços únicos.

### `find_first_laptop_more_expensive`
- **Big O (O)**: A função implementa uma busca binária na lista de laptops ordenados por preço, o que resulta em uma complexidade de O(log k), onde k é o número de laptops.
- **Big Theta (Θ)**: A complexidade de tempo Θ(log k) é uma descrição precisa da complexidade, pois a função sempre divide a lista de laptops ao meio em cada iteração.
- **Big Omega (Ω)**: A complexidade de tempo Ω(log k) é uma cota inferior precisa para a função, pois a busca binária é eficiente e sempre reduz pela metade o espaço de busca.

### `find_laptops_in_price_range`
- **Big O (O)**: A função implementa uma busca binária na lista de laptops ordenados por preço, o que resulta em uma complexidade de O(log k), onde k é o número de laptops.
- **Big Theta (Θ)**: A complexidade de tempo Θ(log k) é uma descrição precisa da complexidade, pois a função sempre divide a lista de laptops ao meio em cada iteração.
- **Big Omega (Ω)**: A complexidade de tempo Ω(log k) é uma cota inferior precisa para a função, pois a busca binária é eficiente e sempre reduz pela metade o espaço de busca.

### `find_laptops_in_price_range_fast`
- **Big O (O)**: A função começa encontrando o índice do primeiro laptop com preço maior ou igual a min_price usando a função find_first_laptop_more_expensive. A complexidade dessa função é logarítmica em relação ao número de laptops, pois utiliza busca binária na lista ordenada, o que resulta em uma complexidade de O(log n), onde n é o número de laptops. Em seguida, a função percorre a lista ordenada de laptops até encontrar laptops fora da faixa de preço. A quantidade de laptops dentro da faixa de preço afeta a quantidade de iterações necessárias. Portanto, a parte do loop tem uma complexidade potencial de O(k), onde k é o número de laptops dentro da faixa de preço. Em resumo, a complexidade total da função depende de ambas as partes: O(log n) para encontrar o primeiro laptop e O(k) para percorrer os laptops dentro da faixa de preço. No pior caso, a complexidade é O(log n + k).
- **Big Theta (Θ)**: A complexidade de tempo Θ(log n + k) é uma descrição precisa da complexidade, pois leva em consideração tanto a busca binária quanto o número de laptops dentro da faixa de preço.
- **Big Omega (Ω)**: A complexidade de tempo Ω(log n + k) é uma cota inferior precisa para a função, pois a função sempre precisa encontrar o primeiro laptop com preço maior ou igual a min_price e percorrer os laptops dentro da faixa de preço.

### `is_laptop_match`
- **Big O (O)**: A função realiza operações lineares para encontrar correspondências para a quantidade de RAM e a capacidade de armazenamento na descrição do laptop, resultando em O(n + m), onde n é o tamanho da string da descrição de RAM e m é o tamanho da string da descrição de armazenamento. A verificação das especificações de RAM e armazenamento é uma operação de tempo constante. Portanto, a complexidade de tempo total é O(n + m).
- **Big Theta (Θ)**: A complexidade de tempo Θ(n + m) é uma descrição precisa da complexidade, pois a função sempre precisa encontrar correspondências para RAM e armazenamento, independentemente dos valores exatos.
- **Big Omega (Ω)**: A função sempre precisa encontrar correspondências para RAM e armazenamento, o que implica que a complexidade de tempo Ω(n + m) é uma cota inferior precisa para a função.

### `find_cheapest_laptop_with_specifications`
- **Big O (O)**: A função envolve duas etapas principais: filtragem de laptops que atendem às especificações (O(k * (n + m)), onde k é o número de laptops, n é o tamanho da string da descrição de RAM e m é o tamanho da string da descrição de armazenamento); encontrar o laptop mais barato entre os laptops filtrados (O(k)).
Portanto, a complexidade de tempo total é O(k * (n + m)), onde k é o número de laptops, n é o tamanho da string da descrição de RAM e m é o tamanho da string da descrição de armazenamento.
- **Big Theta (Θ)**: A complexidade de tempo Θ(k * (n + m)) é uma descrição precisa da complexidade, pois a função sempre precisa percorrer a lista de laptops e verificar as especificações de RAM e armazenamento.
- **Big Omega (Ω)**: A função sempre precisa percorrer a lista de laptops e verificar as especificações de RAM e armazenamento, o que implica que a complexidade de tempo Ω(k * (n + m)) é uma cota inferior precisa para a função.
